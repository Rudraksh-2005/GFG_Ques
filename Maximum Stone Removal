class DSU{
    public:
    vector<int> parent, rank;
    DSU(int n){
        rank.resize(n+1, 0);
        parent.resize(n);
        for(int i = 0; i < n; ++i) parent[i] = i;
    }
    int findUlPar(int node){
        if(node == parent[node]) return node;
        return parent[node] = findUlPar(parent[node]);
    }
    void unionByRank(int u, int v){
        int ulp_u = findUlPar(u);
        int ulp_v = findUlPar(v);
        if(rank[ulp_u] < rank[ulp_v]) parent[ulp_u] = ulp_v;
        else if(rank[ulp_v] < rank[ulp_u]) parent[ulp_v] = ulp_u;
        else{
            parent[ulp_v] = ulp_u;
            rank[ulp_u]++;
        }
    }
};

class Solution {
  public:
    int maxRemove(vector<vector<int>>& stones) {
        // Code here
         int n = stones.size();
        
       
        int maxr = 0, maxc = 0;
        for (auto& stone : stones) {
            maxr = max(maxr, stone[0]);
            maxc = max(maxc, stone[1]);
        }

        
        DSU ds(maxr + maxc + 2); 

        unordered_map<int, int> stonenode;

        for (auto& stone : stones) {
            int noderow = stone[0];
            int nodecol = stone[1] + maxr + 1;  
            ds.unionByRank(noderow, nodecol);

            stonenode[noderow] = 1;
            stonenode[nodecol] = 1;
        }

        int cnt = 0;
        for (auto& node : stonenode) {
            if (ds.findUlPar(node.first) == node.first) {
                cnt++;
            }
        }

        return n - cnt;
    }
};
